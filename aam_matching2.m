% AAM Matching script
% Algorithm: Iterative Model Optimization
%
% This script runs on the global workspace. Thus you must rename all variable
% names in this script to match with your own variable names. Otherwise this
% script will raise error messages.
% 
% Variables used in this script to be replaced by you:
% 1. shape_m = PCA shape model,
% 2. texture_m = PCA texture model,
% 3. app_m = PCA combined appearance model,
% 4. Ws = weighting matrix in the appearance model,
% 5. mask = mask of grid points from the mean shape,
% 6. Rt = pose prediction matrix,
% 7. Rc = appearance parameter prediction matrix
% ------------------------------------------------------------------------------


% PREPARATION: select and load image to search
% ------------------------------------------------------------------------------

% Load file test
ftest = importdata('samri_data/mri_sa_tests.txt');
truth = importdata('shortaxes_test.mat');

% Load regressive data
Rt = importdata('Rt50.mat');
Rc = importdata('Rc50.mat');

% Select which test image you want to use
idx = input('Test image [1-5] = ');

if( idx<1 || idx>length(ftest) ) error('Index is out of range.'); end

% Load image
warning off;
img = double(imread(sprintf('samri_data/%s',ftest{idx})));
warning on;
disp(sprintf('Image %s has been loaded.',ftest{idx}));



% AAM INITIALIZATION: initial pose parameters and some initial conditions
% ------------------------------------------------------------------------------

% Initial pose parameters
P0 = initial_pose(img,shape_m.mean);

% Calculate Qs & Qg, such that generating shape and texture would be:
%   shape = mean_shape + Qs * b
%   texture = mean_texture + Qg * b

Qg = texture_m.phi * app_m.phi((size(shape_m.phi,2)+1):end,:);
Qs = shape_m.phi * inv(Ws) * app_m.phi(1:size(shape_m.phi,2),:);


% Define damping vector
k = [1.5 0.5 0.25 0.125 0.0625];

% Initialize model parameters as a zero vector
c = zeros(size(app_m.b(:,1)));

% Initialize shape generated by the model
xm = shape_m.mean + Qs * c;

% Initialize the matched shape
xmatch = transform_shapes(xm,P0);

% create figure
sz = get(0,'ScreenSize');
wd = 500;
figure('Color','k','DoubleBuffer','on','Position',[0.5*(sz(3)-2*wd) 0.5*(sz(4)-wd) 2*wd wd]);
h1 = axes('Position',[0 0 0.5 1],'Visible','off');
h2 = axes('Position',[0.5 0 0.5 1],'Visible','off');

% Show the image test and initial xmatch
axes(h1);
imagesc(img); colormap(gray); axis image;
h = plot_shapes(xmatch,'-r.');
drawnow;

ht = [];
hclim = [-0.002 0.002];

% Now we wait for any key pressed
disp('Resize your image window to show the iteration clearly and then press any key to continue.');
pause;

% Initial iteration parameters
Epre = Inf;     % previous error
converge = 0;   % set not converge
iter = 0;       % iteration number


% AAM SEARCH ITERATION
% ------------------------------------------------------------------------------

% DONT FORGET to replace all variable names listed above to your own.

while( ~converge )
    
    % Generate texture model from current model parameters, c.
    gm = texture_m.mean + Qg * c;
        
    % Warping and intensity sampling
    pts = thin_plate_spline(shape_m.mean,xmatch,mask);
    gim = intensity_sampling(img,pts);
    
    % Normalize gim into gs
    u = texture_pose(gim,texture_m.mean);
    gs = (gim - u(2)) / (1 + u(1));
    
    % Evaluate error vector and error
    dg0 = gs - gm;
    E0 = norm(dg0);
    
    % Predict displacement pose & parameters
    dt = Rt * dg0;
    dc = Rc * dg0;
    
    % Try using damping vectors
    cached = 0; i = 1;
    while( i<=length(k) && ~cached )
        
        % Update model parameters c
        c = c - k(i) * dc;
        
        % Update image
        axes(h1);
        delete(h);
        h = plot_shapes(xmatch,'-m.');
        drawnow;
        
        % Transform the shape to invert the dt transformation
        xm = transform_shapes(xmatch,P0,'invert',1);
        xmatch = transform_shapes(transform_shapes(xm,-dt),P0);
        
        % Update difference patch
        axes(h2);
        delete(ht);
        ht = plot_texture(mask,dg0);
        caxis(hclim);
%        fprintf(1,'Clim = [%f %f]\n',get(h2,'CLim'));
        drawnow;
    
        % Repeat texture modeling, warping sampling and texture normalization
        gm = texture_m.mean + Qg * c;
        pts = thin_plate_spline(shape_m.mean,xmatch,mask);
        gim = intensity_sampling(img,pts);
        u = texture_pose(gim,texture_m.mean);
        gi = (gim - u(2)) / (1 + u(1));
        
        % Evaluate error vector and error
        dgi = gi - gm;
        Ei = norm(dgi);

        % Check whether Ei <= E0, otherwise increase i
        if( Ei > E0 )
            i = i+1;
        else
            cached = 1;
        end
        
    end
    
    % Save current E
    E = Ei;
    
    % Compare E with Epre (previous E)
    dE = abs(E-Epre);
    pause;
    % Define convergence
    converge = dE < 10e-5;
    if( ~converge ) Epre = E; end
    
    % Show iteration number
    iter = iter+1;
    disp(sprintf('Iteration %d, dE = %f',iter,dE));
    
end


% MATCH FOUND
% ------------------------------------------------------------------------------

% Update image and plot also the truth contour
% The truth is yellow and the matched is green.
axes(h1);
delete(h);
plot_shapes(truth(:,idx),'-y');
h = plot_shapes(xmatch,'-g.');
drawnow;

% Calculate errors
err = abs(xmatch - truth(:,idx));
disp(sprintf('Average point-to-point error = %f, stddev = %f',mean(err),std(err)));